---
title: XQuery と静的入力 |Microsoft Docs
ms.custom: ''
ms.date: 03/17/2017
ms.prod: sql
ms.prod_service: sql
ms.reviewer: ''
ms.technology: xml
ms.topic: language-reference
dev_langs:
- XML
helpviewer_keywords:
- XQuery, static typing
- static typing
- checking static types
- inference [XQuery]
ms.assetid: d599c791-200d-46f8-b758-97e761a1a5c0
author: rothja
ms.author: jroth
manager: craigg
ms.openlocfilehash: 232b071c11d4a2a0bb2e42b6f9787d07f99e21e2
ms.sourcegitcommit: 170c275ece5969ff0c8c413987c4f2062459db21
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/11/2019
ms.locfileid: "54226589"
---
# <a name="xquery-and-static-typing"></a>XQuery と静的な型指定
[!INCLUDE[tsql-appliesto-ss2012-xxxx-xxxx-xxx-md](../includes/tsql-appliesto-ss2012-xxxx-xxxx-xxx-md.md)]

  [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] の XQuery は静的型指定の言語です。 つまり、特定の関数または演算子が許容できない型またはカーディナリティを持つ値が式から返される場合、クエリのコンパイル時に型エラーを生成します。 また静的な型チェックでは、型指定された XML ドキュメントのパス式に型の誤りがあるとそれを検出します。 XQuery コンパイラは、アトミック化などの暗黙的な操作を加える正規化を適用してから、静的な型の推定および確認を行います。  
  
## <a name="static-type-inference"></a>静的な型の推定  
 静的な型の推定では、式の戻り型が判定されます。 この判定は、入力パラメーターの静的な型および演算の静的なセマンティクスを取得し、結果の静的な型を推定することで行われます。 たとえば、式 1 + 2.3 の静的な型は次のようにして判定されます。  
  
-   1 の静的な型は**xs:integer** 2.3 の静的な型であり**xs:decimal**します。 動的のセマンティクスの静的なセマンティクスに基づく、 **+** 操作、整数を 10 進数に変換し、10 進数を返します。 推論された静的な型になりますし**xs:decimal**します。  
  
 型指定されていない XML インスタンスのために、データが型指定されていないことを示す特別な型があります。 その情報は、静的な型チェックのときに暗黙的に型をキャストするために使用されます。  
  
 型指定されたデータの場合、XML データ型インスタンスを制約する XML スキーマ コレクションから入力の型が推定されます。 たとえば、スキーマ型の要素のみを許可する**xs:integer**、型の 0 個以上の要素、その要素を使用して、パス式の結果になる**xs:integer**します。 などの式を使用して、この表現は、現在`element(age,xs:integer)*`、アスタリスク (\*)、結果の型のカーディナリティを示します。 名前"age"と型の 0 個以上の要素で、この例では式の結果が**xs:integer**します。 他の基数は正確に 1 つと単独で、型名を使用して表されます 0 個または 1 と疑問符 () を使用して表されます (**でしょうか**)、および 1 または詳細、プラス記号を使用して表されます (**+**).  
  
 静的な型の推定により、式が常に空のシーケンスを返すことを推定できる場合があります。 たとえば、パス式で型指定された XML データ型の検索、\<名 > 内の要素を\<顧客 > (顧客/名前)、要素は、スキーマが許可しない、\<名 > 内で、\<顧客 >、静的な型の推論は、結果を空にすることを推論します。 これは不適切なクエリを検出するために使用して、式が () しない限り、静的なエラーとして報告されますまたは**データ (())** します。  
  
 推定規則の詳細は、XQuery 仕様の正式なセマンティクスで定義されています。 マイクロソフトでは、型指定された XML データ型のインスタンスに対応するためにこの規則を少しだけ変更しました。 標準からの最も重要な変更点は、暗黙的なドキュメント ノードで XML データ型のインスタンスの型を認識することです。 その結果、認識された情報を基に /age のような形式のパス式も正確に型指定されます。  
  
 使用して[SQL Server Profiler のテンプレートと権限](../tools/sql-server-profiler/sql-server-profiler-templates-and-permissions.md)クエリのコンパイルの一部として返される静的な型を確認できます。 これらを確認するには、トレースに TSQL イベント カテゴリの XQuery Static Type イベントが含まれている必要があります。  
  
## <a name="static-type-checking"></a>静的な型チェック  
 静的な型チェックにより、ランタイムの実行時に、演算に適合する型の値のみを受け取れるようになります。 実行時には必ずしも型がチェックされるとは限りませんが、コンパイルの初期段階で潜在的なエラーを検出できます。 その結果パフォーマンスを向上できます。 ただし、静的な型指定を使用する場合、クエリの記述には通常以上の配慮が必要になります。  
  
 次に、使用できる適切な型を示します。  
  
-   関数または演算により明示的に許可されている型。  
  
-   明示的に許可されている型のサブタイプ。  
  
 サブタイプは、XML スキーマの制約または拡張による派生を使用するためのサブタイプ指定規則に基づいて定義されます。 たとえば、型が S であるすべての値が型 T のインスタンスでもある場合、型 S は型 T のサブタイプです。  
  
 また、XML スキーマの型階層に基づき、integer 型のすべての値は decimal 型の値でもあります。 一方、decimal 型のすべての値が integer 型の値であるとは限りません。 したがって、integer 型は decimal 型のサブタイプですが、逆は違います。 たとえば、 **+** 操作では、数値型など、特定の種類の値のみが許可**xs:integer**、 **xs:decimal**、 **xs:float**、および**xs:double**します。 などの他の値型する場合**xs:string**が渡されると、操作は、型エラーが発生します。 これを厳密な型指定と呼びます。 また、型指定されていない XML を示すアトミック型など、他の型の値から演算で受け入れることのできる型の値に暗黙的に変換することができます。 これを弱い型指定と呼びます。  
  
 暗黙的な変換の後での静的な型チェックを必須にした場合、カーディナリティが正しく、許可された型の値のみが演算に渡されます。 "String"+ 1 の場合は"string"の静的な型は、ことを認識**xs:string**します。 許容される型でないため、 **+** 操作、型エラーが発生します。  
  
 任意の式 E1 の結果に任意の式 E2 を加算する (E1 + E2) 場合、静的な型の推定によって E1 および E2 の静的な型が判定されたうえで、それらの型が演算に許可されている型であるかどうかのチェックが行われます。 たとえば、E1 の静的な型には、いずれかを指定できる場合は、 **xs:string**または**xs:integer**実行時が整数である場合でも、いくつかの値で、静的な型チェック、型のエラーを発生させます。 大文字と小文字 E1 の静的な型の場合も同様**xs:integer&#42;** します。 **+** 操作は 1 つの整数値のみを受け入れる、E1 は 0 を返すことができ、または、1 つ以上の静的な型チェック エラーが発生します。  
  
 既に説明したように、型の推定の結果、渡されるデータの型についてユーザーが認識しているよりも範囲の広い型が導かれることがよくあります。 そのような場合は、ユーザーがクエリを書き換える必要があります。 よく見られるケースを次に示します。  
  
-   スーパータイプまたは型の共用体など、汎化された型が推定される。 アトミック型の場合は、キャスト式またはコンストラクター関数を使用して実際の静的な型を指定してください。 たとえば、式 E1 の推論された型の間での選択肢は、 **xs:string**または**xs:integer**を追加する必要があります**xs:integer**を記述する必要があります`xs:integer(E1) + E2`の代わりに`E1+E2`します。 文字列値が検出された場合、実行時にこの式が失敗するキャストできません**xs:integer**します。 ただし、この式は静的な型チェックには合格します。 この式は空のシーケンスにマップされます。  
  
-   データの実際の内容を上回るカーディナリティが推定される。 これは、多くの場合、 **xml**データ型は、1 つ以上の最上位要素を含めることができ、XML スキーマ コレクションで制約することはできません。 静的な型を限定し、渡される値の数を 1 以下にするためには、位置関係の述語 `[1]` を使用してください。 たとえば、最上位要素 a の下にある要素 `c` の属性 `b` の値に 1 を加算するには、「`write (/a/b/@c)[1]+1`」と記述する必要があります。 また、XML スキーマ コレクションと共に DOCUMENT キーワードを使用できます。  
  
-   一部の演算が推定時に型の情報を失う。 たとえば、ノードの種類を決定できない場合になった**anyType**します。 この型は他の型に暗黙的にキャストされることはありません。 これらの変換は、parent 軸を使用したナビゲーションで特に発生します。 式で静的な型のエラーが発生する場合、そのような演算の使用は避け、クエリを書き換えてください。  
  
## <a name="type-checking-of-union-types"></a>union 型の型チェック  
 union 型は型チェックがあるので注意して処理する必要があります。 ここでは、例を使って 2 つの問題を説明します。  
  
### <a name="example-function-over-union-type"></a>例:Union 型に関数  
 union 型の <`r`> 要素の定義を考えてみます。  
  
```  
<xs:element name="r">  
<xs:simpleType>  
   <xs:union memberTypes="xs:int xs:float xs:double"/>  
</xs:simpleType>  
</xs:element>  
```  
  
 "Average"、関数、XQuery のコンテキスト内で`fn:avg (//r)`XQuery コンパイラは、さまざまな種類の値を追加できないため、静的なエラーを返します (**xs:int 型**、 **xs:float**または**xs:二重**) の <`r`> 要素の引数で**fn:avg()** します。 これを解決するには、関数の呼び出し部分を「`fn:avg(for $r in //r return $r cast as xs:double ?)`」と書き換えます。  
  
### <a name="example-operator-over-union-type"></a>例:Union 型に演算子  
 加算演算子 ('+') を使用するにはオペランドの正確な型が必要です。 したがって、式 `(//r)[1] + 1` は既に説明した要素 <`r`> の型定義に関する静的なエラーを返します。 解決策の 1 つは、「`(//r)[1] cast as xs:int? +1`」("?" は 0 回または 1 回の出現を示す) に書き換える方法です。 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では、すべてのキャストは実行時エラーの結果として空のシーケンスになる可能性があるので、"cast as" に "?" を付ける必要があります。  
  
## <a name="see-also"></a>参照  
 [XQuery 言語リファレンス &#40;SQL Server&#41;](../xquery/xquery-language-reference-sql-server.md)  
  
  
